---
title: How to use Server Side Verification with Web3Auth
image: "guides-banners/ssv.png"
description: Learn how to use Web3Auth Server Side Verification inside a Next.js application.
type: guide
tags: [web, next.js, server side verification, plug and play]
date: July 26, 2022
author: Web3Auth Team
communityPortalTopicId: 65
---

import GoogleAppSetup from "@site/src/common/guides/_google-app-setup.mdx";
import SetupNextjsProject from "@site/src/common/guides/_setup-nextjs-project.mdx";
import SetupWeb3AuthDashboard from "@site/src/common/guides/_setup-web3auth-dashboard.mdx";
import Web3AuthPrerequisites from "@site/src/common/guides/_web3auth-prerequisites.mdx";
import SEO from "@site/src/components/SEO";
import GoogleToggle from "@site/static/images/dashboard/authentication-social-connections.png";
import GoogleConnection from "@site/static/images/dashboard/google-connection.png";

<SEO
  title="How to use Server Side Verification with Web3Auth"
  description="Learn how to use Web3Auth Server Side Verification inside a Next.js application."
  image="https://web3auth.io/docs/guides-banners/ssv.png"
  slug="/guides/server-side-verification"
/>

This guide will cover the basics of how to use Web3Auth's Server Side Verification to verify the ID
token received from Web3Auth after a successful authentication with Google login.

## Quick Start

```bash
npx degit Web3Auth/web3auth-pnp-examples/web-modal-sdk/other/server-side-verification-example w3a-ssv-demo && cd w3a-ssv-demo && npm install && npm run dev
```

## Prerequisites

<Web3AuthPrerequisites />

- A [Google Developer](https://console.developers.google.com) account to be used as Login provider
  for Web3Auth authentication.

## Setup

### Setup your Google App

1. Follow Google's instructions to
   [set up an OAuth 2.0 app.](https://support.google.com/cloud/answer/6158849?hl=en)
2. Paste the following URI as a redirect URI into the "Authorized redirect URIs" field:

   - `https://auth.web3auth.io/auth`

   ![Google OAuth2.0 App Dashboard](/guides/social-providers/google/google-app-redirect-uri.png)

3. Obtain the OAuth `Client ID` from the
   [App on the Google Developer dashboard](https://console.developers.google.com/)

### Setup your Web3Auth Dashboard

<SetupWeb3AuthDashboard />

### Create a Google Connection

Follow these steps to create a Google connection:

1. Visit the [Web3Auth Dashboard](https://dashboard.web3auth.io).
2. Go to the `Social Connections` section.
3. Click on the `Settings` icon near the Google connection.
4. Enter the `Auth Connection ID` (e.g., "w3a-google-ssv").
5. Enter the `Google Client ID` you obtained from the Google Developer dashboard.
6. Finally, click on the `Add Connection` button.

<div style={{ display: "flex", margin: "20px 0" }}>
  <img
    src={GoogleConnection}
    style={{
      maxWidth: "600px",
      borderRadius: "8px",
      boxShadow: "0 2px 6px rgba(0, 0, 0, 0.1)",
    }}
    alt="Google Connection"
  />
</div>

### Setup your Next.js Project

<SetupNextjsProject />

## Using the Web3Auth SDK

To use the Web3Auth SDK, you need to add the dependency of the respective platform SDK of Web3Auth
to your project. To know more about the available SDKs, please have a look at this
[documentation page](/sdk).

For this guide, we will be using the Web3Auth Modal SDK with React hooks and integrating it with
Next.js for server-side verification.

### Installation

Install the required dependencies:

```bash
npm install @web3auth/modal jose next
```

For blockchain interactions, we'll use wagmi:

```bash
npm install wagmi viem @tanstack/react-query
```

### Setting up Web3Auth in Next.js

We need to set up the Web3Auth context configuration:

```tsx title="app/web3authContext.tsx"
import { WEB3AUTH_NETWORK, type Web3AuthOptions } from "@web3auth/modal";

// Get client ID from https://dashboard.web3auth.io
const clientId = process.env.NEXT_PUBLIC_WEB3AUTH_CLIENT_ID || "";

// Instantiate SDK
const web3AuthOptions: Web3AuthOptions = {
  clientId,
  web3AuthNetwork: WEB3AUTH_NETWORK.SAPPHIRE_MAINNET,
  authBuildEnv: "testing",
};

const web3AuthContextConfig = {
  web3AuthOptions,
};

export default web3AuthContextConfig;
```

Then, wrap your application with the Web3Auth provider and Wagmi provider:

```tsx title="app/page.tsx"
"use client";

// Setup Web3Auth Provider
import { Web3AuthProvider } from "@web3auth/modal/react";
import web3AuthContextConfig from "./web3authContext";
// Setup Wagmi Provider
import { WagmiProvider } from "@web3auth/modal/react/wagmi";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";

import App from "./App";

const queryClient = new QueryClient();

export default function Home() {
  return (
    <Web3AuthProvider config={web3AuthContextConfig}>
      <QueryClientProvider client={queryClient}>
        <WagmiProvider>
          <App />
        </WagmiProvider>
      </QueryClientProvider>
    </Web3AuthProvider>
  );
}
```

### Server-Side Verification Endpoint

Create an API route in Next.js to verify the ID token:

```typescript title="app/api/login/route.ts"
import * as jose from "jose";
import { NextResponse } from "next/server";

export async function POST(request: Request) {
  try {
    const authHeader = request.headers.get("authorization");
    const idToken = authHeader?.split(" ")[1] || "";

    const body = await request.json();
    const app_pub_key = body.appPubKey;

    const jwks = jose.createRemoteJWKSet(new URL("https://api.openlogin.com/jwks"));
    const jwtDecoded = await jose.jwtVerify(idToken, jwks, {
      algorithms: ["ES256"],
    });

    if (
      (jwtDecoded.payload as any).wallets
        .find((x: { type: string }) => x.type === "web3auth_app_key")
        .public_key.toLowerCase() === app_pub_key.toLowerCase()
    ) {
      // Verified
      return NextResponse.json({ name: "Validation Success" }, { status: 200 });
    } else {
      return NextResponse.json({ name: "Failed" }, { status: 400 });
    }
  } catch (error) {
    return NextResponse.json({ error }, { status: 500 });
  }
}
```

### Authentication and Verification

In your main application component, use Web3Auth hooks for authentication and call your server
endpoint for verification:

```tsx title="app/App.tsx"
import {
  useWeb3AuthConnect,
  useWeb3AuthDisconnect,
  useWeb3AuthUser,
  useIdentityToken,
  useWeb3Auth,
} from "@web3auth/modal/react";
import { useAccount } from "wagmi";
import { toast } from "react-toastify";
import { useEffect } from "react";
import { WALLET_CONNECTORS, AUTH_CONNECTION } from "@web3auth/modal";

function App() {
  const {
    connect,
    isConnected,
    loading: connectLoading,
    error: connectError,
  } = useWeb3AuthConnect();
  const {
    disconnect,
    loading: disconnectLoading,
    error: disconnectError,
  } = useWeb3AuthDisconnect();
  const { userInfo } = useWeb3AuthUser();
  const {
    token,
    getIdentityToken,
    loading: idTokenLoading,
    error: idTokenError,
  } = useIdentityToken();
  const { web3Auth } = useWeb3Auth();
  const { address, connector } = useAccount();

  function uiConsole(...args: any[]): void {
    const el = document.querySelector("#console>p");
    if (el) {
      el.innerHTML = JSON.stringify(args || {}, null, 2);
      console.log(...args);
    }
  }

  const validateIdToken = async () => {
    await getIdentityToken();
    const pubKey = await web3Auth?.provider?.request({ method: "public_key" });

    // Validate idToken with server
    const res = await fetch("/api/login", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ appPubKey: pubKey }),
    });
    if (res.status === 200) {
      toast.success("JWT Verification Successful");
      uiConsole(`Logged in Successfully!`, userInfo);
    } else {
      toast.error("JWT Verification Failed");
      console.log("JWT Verification Failed");
      await disconnect();
    }
    return res.status;
  };

  useEffect(() => {
    const init = async () => {
      try {
        if (isConnected) {
          await validateIdToken();
        }
      } catch (error) {
        console.error(error);
      }
    };

    init();
  }, [isConnected]);

  // Implicit Login with Google
  const handleGoogleLogin = async () => {
    try {
      await connect(WALLET_CONNECTORS.AUTH, {
        authConnection: AUTH_CONNECTION.GOOGLE,
        authConnectionId: "w3a-google-ssv", // The connection ID you created in the dashboard
      });
    } catch (error) {
      console.error("Login failed", error);
    }
  };

  // Render UI based on connection state
  return (
    <div className="container">
      <h1 className="title">Web3Auth & Next.js Server Side Verification Example</h1>

      {!isConnected ? (
        <div>
          <button onClick={handleGoogleLogin}>Login with Google</button>
          {connectLoading && <div>Connecting...</div>}
          {connectError && <div>Error: {connectError.message}</div>}
        </div>
      ) : (
        <div>
          <h2>Connected to {connector?.name}</h2>
          <div>Address: {address}</div>
          <div>
            <button onClick={() => uiConsole(userInfo)}>Get User Info</button>
            <button onClick={() => getIdentityToken().then(() => uiConsole(token))}>
              Get ID Token
            </button>
            <button onClick={validateIdToken}>Validate ID Token</button>
            <button onClick={() => disconnect()}>Log Out</button>
          </div>
        </div>
      )}

      <div id="console" style={{ whiteSpace: "pre-line" }}>
        <p></p>
      </div>
    </div>
  );
}

export default App;
```

### JWT Login with Google One Tap (Alternative Method)

You can also use Google One Tap for a more streamlined login experience:

```tsx
import { GoogleLogin, CredentialResponse } from "@react-oauth/google";

function App() {
  // ... other code from earlier example

  // JWT Login with Google One Tap
  const loginWithGoogleOneTap = async (response: CredentialResponse) => {
    const idToken = response.credential;

    await connect(WALLET_CONNECTORS.AUTH, {
      authConnectionId: "w3a-google-ssv",
      authConnection: AUTH_CONNECTION.GOOGLE,
      idToken,
      extraLoginOptions: {
        isUserIdCaseSensitive: false,
      },
    });
  };

  return (
    <div className="container">
      {/* ... other UI components */}

      {!isConnected && (
        <div>
          <button onClick={handleGoogleLogin}>Login with Google</button>
          <div className="or-divider">OR</div>
          <GoogleLogin
            onSuccess={loginWithGoogleOneTap}
            onError={() => {
              console.log("Login Failed");
            }}
            useOneTap
          />
        </div>
      )}

      {/* ... rest of the UI */}
    </div>
  );
}
```

### Interacting with Blockchain

With the Web3Auth and Wagmi integration, you can easily interact with blockchain. Here are some
examples:

#### Getting Balance

```tsx title="components/getBalance.tsx"
import { useAccount, useBalance } from "wagmi";
import { formatUnits } from "viem";

export function Balance() {
  const { address } = useAccount();

  const { data, isLoading, error } = useBalance({ address });

  return (
    <div>
      <h2>Balance</h2>
      <div>
        {data?.value !== undefined && `${formatUnits(data.value, data.decimals)} ${data.symbol}`}{" "}
        {isLoading && "Loading..."} {error && "Error: " + error.message}
      </div>
    </div>
  );
}
```

#### Sending Transactions

```tsx title="components/sendTransaction.tsx"
import { FormEvent } from "react";
import { useWaitForTransactionReceipt, useSendTransaction, BaseError } from "wagmi";
import { Hex, parseEther } from "viem";

export function SendTransaction() {
  const { data: hash, error, isPending, sendTransaction } = useSendTransaction();

  async function submit(e: FormEvent<HTMLFormElement>) {
    e.preventDefault();
    const formData = new FormData(e.target as HTMLFormElement);
    const to = formData.get("address") as Hex;
    const value = formData.get("value") as string;
    sendTransaction({ to, value: parseEther(value) });
  }

  const { isLoading: isConfirming, isSuccess: isConfirmed } = useWaitForTransactionReceipt({
    hash,
  });

  return (
    <div>
      <h2>Send Transaction</h2>
      <form onSubmit={submit}>
        <input name="address" placeholder="Address" required />
        <input name="value" placeholder="Amount (ETH)" type="number" step="0.000000001" required />
        <button disabled={isPending} type="submit">
          {isPending ? "Confirming..." : "Send"}
        </button>
      </form>
      {hash && <div>Transaction Hash: {hash}</div>}
      {isConfirming && "Waiting for confirmation..."}
      {isConfirmed && "Transaction confirmed."}
      {error && <div>Error: {(error as BaseError).shortMessage || error.message}</div>}
    </div>
  );
}
```

#### Switching Networks

```tsx title="components/switchNetwork.tsx"
import { useChainId, useSwitchChain } from "wagmi";

export function SwitchChain() {
  const chainId = useChainId();
  const { chains, switchChain, error } = useSwitchChain();

  return (
    <div>
      <h2>Switch Chain</h2>
      <h3>Connected to {chainId}</h3>
      {chains.map((chain) => (
        <button
          disabled={chainId === chain.id}
          key={chain.id}
          onClick={() => switchChain({ chainId: chain.id })}
          type="button"
        >
          {chain.name}
        </button>
      ))}

      {error?.message}
    </div>
  );
}
```

## How it works

1. The user logs in using Web3Auth through Google authentication
2. Upon successful login, we retrieve the ID token using `useIdentityToken` hook
3. We also get the user's public key from the provider
4. We send both the ID token and public key to our server endpoint
5. The server validates the ID token using the JWKS (JSON Web Key Set) from Web3Auth
6. It then verifies that the public key from the token matches the one sent by the client
7. If everything checks out, the server responds with a success status, completing the verification
   process

## Example code

The code for the application we developed in this guide can be found in the
[Web3Auth Server Side Verification Example](https://github.com/Web3Auth/web3auth-pnp-examples/tree/main/web-modal-sdk/other/server-side-verification-example).
Check it out and try running it locally yourself!

## Questions?

Ask us on [Web3Auth's Community Support Portal](https://web3auth.io/community)
